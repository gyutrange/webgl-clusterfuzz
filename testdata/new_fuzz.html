<!DOCTYPE html>
<html>
<head>
    <title>Ultimate Chaos Fuzzer: WebGL vs WebGPU Interop</title>
    <style>
        body { font-family: monospace; background: black; color: #ff00ff; }
        h2 { text-shadow: 0 0 8px #ff00ff; }
        #log { max-height: 85vh; overflow-y: auto; white-space: pre-wrap; background: #111; padding: 10px; border: 1px solid #333; }
        .error { color: red; }
        .info { color: cyan; }
    </style>
</head>
<body>
    <h2>Ultimate Chaos Fuzzer: WebGL vs WebGPU</h2>
    <p>This fuzzer creates extreme race conditions between WebGL and WebGPU using the same ImageBitmap resource across multiple workers.</p>
    <button onclick="startFuzz()">üöÄ Unleash Chaos</button>
    <button onclick="stopFuzz()">‚èπÔ∏è Stop</button>
    <pre id="log"></pre>

    <script id="worker_code" type="javascript/worker">
        let gl, gpuDevice, gpuQueue;

        async function initWebGL() {
            if (gl) return true;
            try {
                const canvas = new OffscreenCanvas(1, 1);
                gl = canvas.getContext('webgl2', { antialias: false });
                return !!gl;
            } catch (e) { return false; }
        }

        async function initWebGPU() {
            if (gpuDevice) return true;
            try {
                if (!navigator.gpu) return false;
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) return false;
                gpuDevice = await adapter.requestDevice();
                gpuQueue = gpuDevice.queue;
                return !!gpuDevice;
            } catch (e) { return false; }
        }

        self.onmessage = async (e) => {
            const { bitmap, runId } = e.data;
            try {
                const taskType = Math.random() > 0.5 ? 'webgl' : 'webgpu';
                self.postMessage({ log: `[Worker ${runId}] Starting task: ${taskType}` });

                if (taskType === 'webgl' && await initWebGL()) {
                    const tex = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, tex);
                    // Use the bitmap, then immediately close it to stress the lifecycle
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, bitmap);
                    setTimeout(() => bitmap.close(), 0);
                    gl.generateMipmap(gl.TEXTURE_2D);
                    await gl.finish();
                    gl.deleteTexture(tex);

                } else if (taskType === 'webgpu' && await initWebGPU()) {
                    const destTexture = gpuDevice.createTexture({
                        size: [bitmap.width, bitmap.height],
                        format: 'rgba8unorm',
                        // Correct usage flags
                        usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
                    });
                    // Use the bitmap, then immediately close it
                    gpuQueue.copyExternalImageToTexture({ source: bitmap }, { texture: destTexture }, [bitmap.width, bitmap.height]);
                    setTimeout(() => bitmap.close(), 0);
                    await gpuQueue.onSubmittedWorkDone();
                
                } else {
                     self.postMessage({ log: `[Worker ${runId}] Skipped, required API not available.` });
                }
                 self.postMessage({ log: `[Worker ${runId}] Task finished.` });
            } catch (err) {
                // We are HOPING for a hard crash, but log JS errors too.
                self.postMessage({ log: `[Worker ${runId}] Error: ${err.message}`, type: 'error' });
            }
        };
    </script>

    <script>
        const logEl = document.getElementById('log');
        let fuzzingInProgress = false;

        function log(msg, type = '') {
            const span = document.createElement('span');
            if (type) span.className = type;
            span.textContent = `\n${msg}`;
            logEl.appendChild(span);
            logEl.scrollTop = logEl.scrollHeight;
        }

        async function createValidBitmap() {
            const canvas = new OffscreenCanvas(256, 256);
            canvas.getContext('2d').fillRect(0, 0, 256, 256);
            return await createImageBitmap(canvas);
        }

        async function startFuzz() {
            if (fuzzingInProgress) return;
            fuzzingInProgress = true;
            logEl.innerHTML = "";
            log("--- Starting Chaos Fuzzer ---", "info");

            for (let i = 0; i < 100 && fuzzingInProgress; i++) {
                log(`\n--- Iteration #${i} ---`);
                
                // Use the original chaotic structure: create a fresh bitmap and fresh workers each time
                try {
                    const bitmap = await createValidBitmap();
                    const workers = [];

                    for (let j = 0; j < 8; j++) { // 8 workers competing for one bitmap
                        const runId = `#${i}.${j}`;
                        const blob = new Blob([document.getElementById("worker_code").textContent]);
                        const worker = new Worker(URL.createObjectURL(blob));
                        worker.onmessage = (e) => log(e.data.log, e.data.type);
                        worker.onerror = (e) => log(`[Worker ${runId}] FATAL ERROR: ${e.message}`, 'error');
                        
                        // All workers get a reference to the same bitmap, but only the first transfer succeeds.
                        // This chaos is intentional.
                        try {
                           worker.postMessage({ bitmap, runId }, [bitmap]);
                        } catch(e) {
                           // Expected error: "Value is not transferable" for workers 2-8
                           // This adds to the chaos. Now some workers have a valid handle, some don't.
                           worker.postMessage({ bitmap: null, runId });
                        }
                        workers.push(worker);
                    }
                    
                    // After a short delay, terminate all workers to trigger cleanup races
                    await new Promise(r => setTimeout(r, 200));
                    workers.forEach(w => w.terminate());

                } catch (e) {
                    log(`[Main] CRITICAL ERROR: ${e.message}`, 'error');
                    stopFuzz();
                    return;
                }
                
                if (typeof gc === 'function') gc();
                await new Promise(r => setTimeout(r, 100));
            }

            if (fuzzingInProgress) log("\n--- Fuzzing Finished ---", "info");
            stopFuzz();
        }

        function stopFuzz() {
            fuzzingInProgress = false;
        }
    </script>
</body>
</html>
